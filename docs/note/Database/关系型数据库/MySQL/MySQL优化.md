---
title: MySQL优化
createTime: 2024/10/24 16:40:02
permalink: /article/jlbii97i/
---
# MySQL优化
1. SELECT 后跟列名，替代`*`
2. 避免在WHERE子句中 使用 OR 连接条件
	1. or关键字两侧，只要有一个关键字没有索引，就必须全表扫描
3. 避免在WHERE子句中 使用 `!=` 或 `<>`
	1. 存在不等于运算符时，进行全表扫描
4. SELECT如果只查询一条数据，添加`LIMIT 1`
	1. limit的作用是避免全表扫描；如果查询列是主键项，不用加`limit 1`
5. 优化like语句，模糊匹配 `%|_`放在右边
6. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。
	1. 当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。

# 查询语句优化
## 查询语句原理
### FROM
1. 作用：找表
	1. 将硬盘中的表文件加载到内存，生成一个全新的临时表
	2. 定位内存中已经存在的内存表
2. 注意：
	1. 在一个查询语句中，永远是from语句先执行
	2. from定位的是内存中的一个临时表，该临时表必须手动指定表名【内存中的临时表是没有名字的】

### WHERE
1. 作用：
	1. where命令<font color="#ff0000">操作的是由from命令生成的临时表</font>；
	2. 循环遍历当前临时表的每一个数据行，将满足条件的数据行保存到一个全新的临时表中
2. 注意：
	1. <font color="#ff0000">where子句无法使用聚合函数作为判断条件</font>
		1. 因为where命令每次操作只是一个数据行

### GROUP BY
1. 作用：
	1. 对临时表中的数据进行一次排序处理
	2. 将具有相同特征的数据保存在同一个临时表中（不同的临时表作为分组表）
2. 注意：
	1. 进行多字段分组
		1. <font color="#548dd4">分组字段书写顺序对查询结果没影响</font>
		2. <font color="#548dd4">从第二个分组字段开始，操作的临时表是上一个分组字段生成的临时表</font>
	2. <font color="#ff0000">存在GROUP BY子句的SELECT语句中，SELECT后只能跟 聚合函数 或 group by后面的字段</font>
		1. 因为，此时select遍历group by生成的每一个临时表时，聚合函数会进行汇总处理，但对于查询的字段，select只会读取指定字段中第一个数据行的内容
	3. MySQL不强制要求GROUP BY与SELECT后的列名保持一致，但ORACLE和达梦数据库要求

### HAVING
1. 作用：
	1. 负责 <font color="#548dd4">将</font> group by生成的临时表 中 <font color="#548dd4">不满足条件的临时表</font> <font color="#548dd4">删除</font>
2. 注意
	1. having命令只能出现在group by命令后面
	2. <font color="#ff0000">having命令的操作单元是一个临时表，因此选择判断函数应该来自于聚合函数</font>

### SELECT
1. 作用：
	1. 读取from、where、group by、having子句生成的临时表
2. 注意：
	1. select操作的临时表，由from或由where命令提供。
		1. select将指定字段中所有内容全部读取出来组成一个新的临时表
	2. select操作的临时表，由group by或having命令提供。
		1. 此时select将遍历生成的每一个临时表，读取指定字段的第一个数据行内容，将每个临时表中的查询数据组成一个新的临时表

### ORDER BY
1. 作用：
	1. 对 select生成的临时表中的数据 排序
2. 注意：
	1. order by支持按字段排序和按字段顺序排序
		1. 按字段排序时，排序字段可不出现在Select 后
		2. 按字段顺序排序时（指定查询结果集中的列顺序），排序字段的索引位置必须在 SELECT 查询中的对应位置上

### LIMIT
1. 作用
	1. 对临时表中的数据行进行截取
2. 注意：
	1. 对于自增主键表，可通过 `where id>100 limit 0,10`  替换 `limit 100,10`



## 影响性能的关键因素
1. <font color="#ff0000">数据排序</font>
	1. group by命令：将临时表中的数据先按分组命令中的关键字进行先排序后分组
	2. order by命令：需要对select生成的临时表中的数据进行一次【全表排序】，然后将排序好的临时表组成一个全新的临时表
2. <font color="#ff0000">全表遍历</font>
	1. where命令：对表中的所有数据行进行全表遍历
	2. limit：指定的起始行数过大，导致查询速度过慢
3. <font color="#ff0000">I/O次数过多</font>
	1. 对于多表查询来说，如果没有指定表文件的加载顺序，也会导致查询命令过慢【多表查询时，应该是小表驱动大表的原则】


# 分析工具
## EXPLAIN
### 用法
```sql
explain select
```
### 含义
1. ID属性
	1. 含义：
		1. 用于表示本次查询过程中加载表的顺序或查询子句执行顺序。
	1. 值
		1. id 相同：加载表的顺序是从上到下
		2. id 不同：id 值越大，优先级越高，越先被执行
2. select_type属性
	1. 含义
		1. 对当前查询语句中的查询类型进行判断
	1. 值
		1. Simple：表示当前查询语句是一个简单查询语句。不包含子查询，不包含联合查询，不包含连接查询语句
		2. Primary：如果执行的是一个包含子查询的查询，或则是一个联合查询。Primary 指向的外部查询语句或是联合查询中的第一个子查询
		3. dependency subquery：表示当前查询语句是一个子查询。并且执行条件依赖与外部查询提供的条件
		4. subquery：表示当前查询是一个子查询。并且这个子查询在执行时不需要得到外部查询的帮助。

3. possible_keys属性
	1. 含义
		1. 表示当前查询语句执行时可能用到的索引有哪些，在possible_keys 可能出现多个索引，但是这些索引未必在本次查询中使用到
4. key属性
	1. 含义
		1. 表示当前查询语句真实使用的索引名称。如果这个字段为 null，则有两种可能：一个是当前表中没有索引；二是当前表有索引但是失效了。
5. key_len属性
	1. 含义
		1. 如果本次查询使用了索引。则key_len内容不为空。表示当前索引字段存储内容最大长度。这个长度不是精准值。只是 MySQL 估计的值。这个值越大越精准。在能得到相同结果时，这个值越小那么查询速度越快
6. type属性
	1. 含义
		1. 表示查询语句的执行效率
	1. 可以对查询语句的执行效率大致分级
		2. all：全表扫描（执行效率最低）
		3. index：定位数据行时，没有使用到索引（全表扫描）。但是在已经定位的数据行中读取字段时，使用索引。也就是说使用select命令时，根据索引读取数据。（执行效率较低）
		4. range：定位数据行时，使用到索引。使用区间定位方式`where age< =23`，区间定位方式不稳定，当定位的数据行超过了表中总行数30%以上，会导致mysql放弃使用索引定位。
		5. ref：定位数据行时，使用到索引。采用值等方式`where ename= 'mike'`；
		6. const：定位数据行时，使用到索引，采用主键索引值等方式`[where empno= 10]`
		7. system：操作表只有一行数据，并且数据内容是固定不变的。
7. filtered属性
	1. 含义
		1. 表示查询结果占扫描条数的百分比

## 分析行锁定
```sql
show status like 'innodb_row_lock%';
```
1. 状态量说明：
	1. Innodb_row_lock_current_waits：当前正在等待锁的数量；
	2. Innodb_row_lock_time：从系统启动到现在锁定总时间长度；
	3. Innodb_row_lock_time_avg：每次等待所花平均时间；
	4. Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间长度；
	5. Innodb_row_lock_waits：系统启动到现在总共等待的次数；
2. 对于这5个状态变量，比较重要的是：
	1. Innodb_row_lock_time_avg（等待平均时长），Innodb_row_lock_waits（等待总次数），Innodb_row_lock_time（等待总时长）。
	2. 尤其是当等待次数很高，而且每次等待时长也很大的时候，我们就要分析系统中为什么有这么多的等待，然后根据分析结果来制定优化【show profile】。
