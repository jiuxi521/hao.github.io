---
title: 行锁
createTime: 2024/10/24 16:40:01
permalink: /article/my3cyi4g/
---
# 行锁

## 定义

1. 指对当前操作的数据行进行加锁，控制数据的并发访问；可以大大减少冲突；加锁粒度最小，频繁加锁需要大量申请锁资源，故速度慢，内存消耗大。
## 注意事项
1. InnoDB行级锁本质上是<font color="#ff0000">给表中数据对应索引的索引项加锁</font>实现的，<span style="background:#9254de">只有通过索引访问数据，才会触发行级锁</span>，否则，InnoDB将会使用表级锁
2. 使用锁的时候，如果表没有定义任何索引，那么InnoDB会创建一个[[InnoDB隐藏索引|隐藏的聚簇索引]]并使用这个索引来加<font color="#ff0000">记录锁</font>。

## 功能
1. 防止多个事务对相同数据的并发修改

## 分类
1. [[共享锁]]（读锁，S锁）
2. [[排它锁]]（写锁，X锁）
3. [[意向锁]]
4. [[Next-Key锁]]

## 算法
### 记录锁（Record Lock）
1. 对于键值在条件范围内，且存在的记录，使用" Record Lock "，即普通的行锁机制；
### 间隙锁（Gap Lock）
1. 对于键值在条件范围内，但并不存在的记录，叫做" 间隙（GAP) "，InnoDB会对这个“间隙”加锁，这种锁机制就是所谓的" Gap Lock "(间隙锁)；
### 记录+间隙锁（[[Next-Key锁|Next-Key Lock]]）
1. 对于键值在条件范围内，对存在和不存在的数据同时加锁，则称为" Next-Key Lock "；

## 加锁机制

### 原理

1. <font color="#ff0000">行级锁默认加next-key lock 锁</font>，随加锁条件的不同进行锁的变化
2. 如果删除范围锁中的上下边界索引（当然是未被锁定的索引），范围锁会动态地锁的范围扩大到下一个索引位置。
3. 如果插入的值超过索引中最大值，锁类型变为X锁，被锁的最大行为supremum pseudo-record，它具有大于所有索引的值，不是真正的索引记录。此时，锁的范围扩大到正无穷。

### 加锁策略
> [https://blog.csdn.net/xuejianxinokok/article/details/124515255](https://blog.csdn.net/xuejianxinokok/article/details/124515255)
> [https://blog.csdn.net/qq_31686135/article/details/125682884](https://blog.csdn.net/qq_31686135/article/details/125682884)
> [https://zhuanlan.zhihu.com/p/464560381](https://zhuanlan.zhihu.com/p/464560381)
> [https://www.cnblogs.com/shuimuzhushui/p/11403517.htm](https://www.cnblogs.com/shuimuzhushui/p/11403517.htm)

1. 唯一索引加锁
	1. 等值查询
		1. 存在：退化为记录锁
		2. 不存在：退化为间隙锁，不包含两侧记录
	2. 范围查询
		1. 小于
			1. 存在：(-∞，存在的记录]
			2. 不存在：(-∞，向右查找不满足条件的第一条记录]
		2. 大于
			1. 存在：(存在的记录，+∞)
			2. 不存在：(向左查找不满足条件的第一条记录,+∞)
2. 非唯一索引加锁
	1. 等值查询
		1. 存在|不存在：（查找值的前一个索引，查找值的下一个索引] 默认加临界锁，同时向右查找不满足条件的第一条记录
	2. 范围查询
		1. 小于
			1. 存在：(-∞，存在的记录)
			2. 不存在：(-∞，向右查找不满足条件的第一条记录)
		2. 大于
			1. 存在：[存在的记录，+∞)
			2. 不存在：(向左查找不满足条件的第一条记录,+∞)

## 行锁死锁问题

### 问题产生
1. 由于InnoDB中，锁是逐步获得的，可能造成死锁。在MySQL中，行级锁并不是直接锁记录，而是锁索引。
2. 索引分为主键索引和非主键索引两种。
3. 如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；
4. 如果一条sql语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。
5. 当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。
### 问题解决
1. InnoDB自动解决：发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。
### 问题避免
1. 对于并发存取多个表，约定以相同的顺序访问表
2. 在一个事务中，尽量一次性获取全部资源
3. 对容易发生死锁的部分，提升锁级别