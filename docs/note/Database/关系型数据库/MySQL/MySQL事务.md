---
title: MySQL事务
createTime: 2024/10/24 16:40:02
permalink: /article/kf8q4ho9/
---
## 功能
1. 保证一系列数据库操作全部成功或全部失败；保证数据的一致性和完整性

## 事务的四大特性：ACID

1. A：原子性（Atomicity）
	1. 事务是最小的工作单元，不可再分。
	2. 在事务执行过程中，由于同一个事务内部存在多个语句，一个取钱方法，一个汇款方法，存在不一致性，但是由于事务具有原子性，使得事务中的执行语句全部成功或全部失败，保证了事务的一致性。
2. C：一致性（Consistency）
	1. 数据库的数据状态符合数据库所描述的业务逻辑和规则；事务执行前后，从一个一致性状态到另一个一致性状态。
	2. 拿账户转账来举例一致性状态在于钱的总数不会发生改变，取款账户扣款，另一方的钱会相应的增加。
	3. 主要是保护数据的一致性，防止由于数据库的崩溃而导致的数据一致性问题。举个例子，我们更新 MySQL 的数据，更新的数据会先到 InnoDB 的 Buffer Pool 中，如果此时 MySQL 所在的机器突然意外重启了，如果 InnoDB 没有崩溃恢复机制，之前更新的数据就会丢失，数据的一致性问题就出现了。
3. I： 隔离性（Isolation）：事务A与事务B之间具有隔离
4. D：持久性（Durability）：最终数据必须持久化到硬盘文件中，事务才算成功的结束。⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响

## 事务的隔离级别
> [https://www.jianshu.com/p/69fd2ca17cfd](https://www.jianshu.com/p/69fd2ca17cfd)
> oracle数据库默认的隔离级别是：读已提交。
> mysql数据库默认的隔离级别是：可重复读。
> 	InnoDB 存储引擎在 分布式事务 的情况下⼀般会⽤到 SERIALIZABLE(可串⾏化) 隔离级别。
### 使用锁实现的隔离级别
- 第一级别：读未提交（read uncommitted）
	- 对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。
	- 存在的问题：[[脏读]]（Dirty Read）、[[不可重复读]]、[[幻读]]
- 第二级别：读已提交（read committed）
	- 对方事务提交之后的数据我方可以读取到。
	- 解决了：[[脏读]]
	- 存在的问题：[[不可重复读]]、[[幻读]]
- 第三级别：可重复读（repeatable read）
	- 无论另一个事务对数据进行任意操作（增删改、提交事务），我们看到的是未经修改过的原数据记录，实际上硬盘数据在其他事务提交之后已经发生修改，我们看到的是快照数据。
	- 解决了：[[不可重复读]]
	- 存在的问题：[[幻读]]
- 第四级别：序列化读/串行化读（serializable）
	- 事务需要排队执行，只有当运行事务提交或回滚事务之后，另一个事务才能开始
	- 存在问题：效率低。需要事务排队。
### 使用MVCC实现的隔离级别
SI：快照隔离
1. Snapshot Isolation

## 不同隔离级别的当前读
### 读已提交
1. 每次Select查询都是查询最新的已提交的数据，都是当前读；并且<font color="#ff0000">select查询不会对数据行加锁</font>，所以会发生[[不可重复读]]
### 可重复读
1. 读取最新的已提交的数据；判断当前数据是否存在锁，不存在直接加Next-Key锁，避免了[[不可重复读]]；可能出现[[幻读]]

## 不同隔离级别下的快照读
### 读已提交
1. 使用MVCC的[[Read View]]实现，保证不会读到其他事务未提交的数据，避免了脏读；但未对数据行加锁，可能出现不可重复读

### 可重复读
1. 事务开启后的第一次Select查询生成一个快照读，之后的普通Select查询都使用第一个版本的快照读。这意味着在事务执行期间，多个查询将会看到相同的数据快照，即使其他并发事务提交了数据变更。使用MVCC的[[Read View]]实现。