---
title: 2024-10-21
createTime: 2024/10/24 20:01:16
permalink: /article/npto738s/
---
### 分布式Id
1. 考虑点
	1. 占用空间是否足够小；聚簇索引加载到内存，主键越小，容纳的索引越多，IO次数越少
	2. 安全性：是否可预测
	3. 是否全局唯一
	4. 是否有序：避免索引频繁改动
2. 可用方案：
	1. 数据库自增Id
		1. 自增Id串行计算消耗数据库性能
		2. 自增Id取值有限
			1. int类型是32位的有符号整数，占4个字节；取值范围为`[-2^31=-2147483648,2^31-1=2147483647];
			2. bigint类型64 位的有符号整数，占8个字节；取值范围为`[-2^63,2^63-1];
		3. 分布式系统的分库分表会发生冲突
	2. UUID
		1. 优点
			1. 全局唯一
		2. 缺点
			1. UUID无序，对于InnoDB引擎的聚簇索引，数据频繁插入到数据页中，索引会频繁更改（索引页频繁分裂、移动）
			2. UUID消耗更多空间：格式为`8-4-4-4-12`（十六进制）；使用binary保存需要16字节(`32字符*4=128bit=16字节`)，可读性差；使用varchar保存需要36字符（32位元素+4个破折号）；作为主键，相较雪花Id，每个页（16KB）容纳的数据减少，IO次数变多
	3. [[雪花Id]]
		1. 优点
			1. 全局唯一；有序递增；可预测性低；性能高效
		2. 缺点
			1. 存在时间回拨、数据中心ID、机器Id重复导致的雪花Id重复
			2. 每毫秒生成的ID数量是固定的（序列号的最大值：12bit的最大值为4096），需等待下一毫秒到来才能生成新的Id
# [[雪花Id]]
> [雪花Id 博客](https://blog.csdn.net/sanjun333/article/details/141109845)
## 原理图
![](https://raw.gitmirror.com/jiuxi521/typora/master/202410221125369.png)
雪花算法的工作流程如下：
1. **时间戳**：41位。获取当前时间戳，减去起始时间戳，得到一个**相对时间戳**。
2. **工作机器ID**：10位(一般是5位数据中心+5位机器Id)。每个服务器有一个唯一的ID，这个ID需要事先配置好，并且保证在一个集群中是唯一的。最多支持1024个不同的服务器。
3. **序列号**：对于同一个毫秒内的多个请求，使用序列号来区分，序列号每增加一次就加1，直到达到最大值12位全满（即4096），然后重置为0，等待下一个毫秒到来。
4. **拼接ID**：将上述三部分按位拼接起来，形成最终的64位整数ID。

## 问题
### 时钟回拨
当前时间戳（一般取值机器时间）小于API已记录时间戳，导致时钟回拨；
1. **摆脱对机器时钟的依赖**：可以定义一个初始时间戳，并在需要时自增该时间戳，而不是跟随机器时钟的增加。那么，何时自增这个时间戳呢？一个合理的策略是，当序列号增加到最大值时，将时间戳加1。这种方法能够充分利用序列号，也可以充分利用未来时间，预先生成一些ID并存储在缓存中，特别适用于流量较大的场景。然而，在流量较小的情况下，可能会出现时间断层或滞后的现象。如果对从ID中解析出来的时间戳有特定的利用需求（例如用于记录事件发生的时间），那么这个缺点可能会成为问题。但如果时间戳的利用意义不大，那么这个缺点也就可以忽略不计了。
2. **优化对机器时钟的依赖**：如果仍然选择依赖机器时钟，那么对于小范围的时钟回拨（例如几十毫秒），可以选择等待时钟恢复正常。此外，如果流量不大，可以考虑缓存前几百毫秒或几秒的序列号。当时钟回拨发生时，可以从缓存中获取并自增序列号，从而有效地应对时钟回拨问题。这种方法在保持对机器时钟依赖的同时，降低了时钟回拨对系统的影响。